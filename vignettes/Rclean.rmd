---
title: "Rclean"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Rclean}
  %\VignetteEncoding{UTF-8}
---

<!-- \VignetteEngine{knitr::knitr} -->
<!-- https://bookdown.org/yihui/rmarkdown/r-package-vignette.html -->

Written with research scientists in mind,
[Rclean](https://cran.r-project.org/web/packages/Rclean/)'s primary
function provides a simple way to isolate the minimal code you need to
produce specific results, such as a statistical table or a figure. By
analyzing the relationships among objects and functions, large and/or
complicated analytical scripts can be paired down to the
essentials. This can aid in debugging and re-factoring code and help
to make scientific projects more robust and easily shared.

# Quick-start Guide

You can install
[Rclean](https://cran.r-project.org/web/packages/Rclean/) from *CRAN*: 

```{r eval = FALSE}
install.packages("Rclean")
```

You can install the most up to date version using
[devtools](https://github.com/hadley/devtools):

```{r eval = FALSE}
install.packages("devtools")
devtools::install_github("MKLau/Rclean")
```

Once installed, per usual R practice, just load the *Rclean* package with:

```{r eval = TRUE}
library(Rclean)
```

```{r eval = TRUE, echo = FALSE, results = "hide"}
library(CodeDepends)
script <- system.file(
    "example", 
    "simple_script.R", 
    package = "Rclean")

```

[Rclean](https://cran.r-project.org/web/packages/Rclean/) usage is
simple. Just run the `clean` function with the file path to a script
as the input. We can use an example script that is included with the
package:

```{r eval = FALSE} 
script <- "example/simple_script.R"

```

Here's a quick look at the code:


```{r eval = TRUE}
readLines(script)

```

You can get a list of the variables found in an object with
`get_vars`. 

```{r eval = TRUE}
get_vars(script)

```

Sometimes for more complicated scripts, it can be helpful to see a
network graph showing the interdependencies of variables. `code_graph`
will produce a network diagram showing which lines of code produce or
use which variables (e.g. 1 -> "out"):

```{r eval = TRUE}
code_graph(script)
```

Now, we can pick the result we want to focus on for cleaning:


```{r eval = TRUE}
clean(script, "tab.15")
```

We can also select several variables at the same time:

```{r eval = TRUE}
my.vars <- c("tab.12", "tab.15")
clean(script, my.vars)
```

While just taking a look at the simplified code can be very helpful,
you can also save the code for later use or sharing (e.g. creating a
reproducible example for getting help) with `keep`:

```{r eval = FALSE}
my.code <- clean(script, my.vars)
keep(my.code, file = "results_tables.R")
```

If you would like to copy your code to your clipboard to copy-paste,
you can do that by not specifying a file path. You can now paste the
simplified as needed, such as into another script file or a help forum
thread.

```{r eval = FALSE}
keep(my.code)
```

# Some Thoughts on the Need for "Code Cleaning"

At it's root R is a statistical programming language. That it, it was
designed for use in analytical workflows. As such, the majority of the
R community is focused on producing code for idiosyncratic projects
that are results oriented. Also, R's design is intentionally at a
level that abstracts many aspects of programming that would otherwise
act as a barrier to entry for many users. This is good in that there
are many people who use R to their benefit with little to no formal
training in computer science or software engineering. However, these
same users are also frequently frustrated by code that is fragile,
buggy and complicated enough to quickly become obtuse even to
themselves in a very short amount of time. In addition, when scripts
take an extremely long time to execute, being able to reduce
unnecessary analyses can help increase computation efficiency.


More often then not, when someone is writing an R script, they're
intent on getting a set of results. This set of results is always a
subset of a much larger set of possible ways to explore a dataset, as
there are many statistical approaches and tests, let alone ways to
create visualizations and other representations of patterns in
data. This commonly leads to lengthy, complicated scripts from which
researchers manually subset results, but never refactor (i.e. reduce
to the final subset). In part, this is enabled by a lack of a proper
version control system, and in order to record their process and not
lose work, the entire process remains in a single or several
scripts. Although Rclean is not designed to fix the latter, it can
help with the former issue, once an appropriate versioning system is
adopted (e.g. git or subversion). 



# Example: Cleaning a Complicated Script

When approaching a long or complicated script that needs refactoring,
the multi-variable selection feature in the `clean` function can be
extremely helpful. Here, we've compiled all of the examples using the
`iris` dataset in the Ecodist package into a single script.


```{R complicated}

     data(iris)
     dni3 <- dimnames(iris3)
     ii <- data.frame(matrix(aperm(iris3, c(1,3,2)), ncol = 4,
                 dimnames = list(NULL, sub(" L.",".Length",
				 sub(" W.",".Width", dni3[[2]])))),
				 Species = gl(3, 50, 
				    labels = sub("S", "s", sub("V", "v", dni3[[3]]))))
     all.equal(ii, iris) # TRUE
     data(iris)
     iris.d <- dist(iris[,1:4])
     
     ### nmds() is timeconsuming, so this was generated
     ### in advance and saved.
     ### set.seed(1234)
     ### iris.nmds <- nmds(iris.d, nits=20, mindim=1, maxdim=4)
     ### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
     data(iris.nmds)
     
     # choose the best two-dimensional solution to work with
     iris.nmin <- min(iris.nmds, dims=2)
     
     # generate new data points to add to the ordination
     # this might be new samples, or a second dataset
     
     iris.new <- structure(list(Sepal.Length = c(4.6, 4.9, 5.4, 5.2, 6, 6.5, 6, 
     6.8, 7.3), Sepal.Width = c(3.2, 3.5, 3.6, 2.3, 2.8, 3, 2.7, 3.1, 
     3.2), Petal.Length = c(1.2, 1.5, 1.5, 3.5, 4.1, 4.2, 4.8, 5, 
     5.7), Petal.Width = c(0.26, 0.26, 0.26, 1.2, 1.3, 1.4, 1.8, 2, 
     2), Species = structure(c(1L, 1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L), .Label = c("setosa", 
     "versicolor", "virginica"), class = "factor")), .Names = c("Sepal.Length", 
     "Sepal.Width", "Petal.Length", "Petal.Width", "Species"), class = "data.frame",
     row.names = c(NA, -9L))
     
     # provide a dist object containing original and new data
     # provide a logical vector indicating which samples were used to
     # construct the original configuration
     
     iris.full <- rbind(iris, iris.new)
     all.d <- dist(iris.full[,1:4])
     is.orig <- c(rep(TRUE, nrow(iris)), rep(FALSE, nrow(iris.new)))
     
     ### addord() is timeconsuming, so this was generated
     ### in advance and saved.
     ### set.seed(1234)
     ### iris.fit <- addord(iris.nmin, iris.full[,1:4], all.d, is.orig, maxit=100)
     ### save(iris.fit, file="ecodist/data/iris.fit.rda")
     data(iris.fit)
     
     plot(iris.fit$conf, col=iris.full$Species, pch=c(18, 4)[is.orig + 1],
         xlab="NMDS 1", ylab="NMDS 2")
     title("Demo: adding points to an ordination")
     legend("bottomleft", c("Training set", "Added point"), pch=c(4, 18))
     legend("topright", levels(iris$Species), fill=1:3)
     data(iris)
     iris.d <- dist(iris[,1:4])
     
     ### nmds() is timeconsuming, so this was generated
     ### in advance and saved.
     ### set.seed(1234)
     ### iris.nmds <- nmds(iris.d, nits=20, mindim=1, maxdim=4)
     ### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
     data(iris.nmds)
     
     # examine fit by number of dimensions
     plot(iris.nmds)
	 data(iris)
     iris.d <- dist(iris[,1:4])
     
     ### nmds() is timeconsuming, so this was generated
     ### in advance and saved.
     ### set.seed(1234)
     ### iris.nmds <- nmds(iris.d, nits=20, mindim=1, maxdim=4)
     ### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
     data(iris.nmds)
     
     # examine fit by number of dimensions
     plot(iris.nmds)
     
     # choose the best two-dimensional solution to work with
     iris.nmin <- min(iris.nmds, dims=2)
     
     # rotate the configuration to maximize variance
     iris.rot <- princomp(iris.nmin)$scores
     
     # rotation preserves distance apart in ordination space
     cor(dist(iris.nmin), dist(iris.rot))
     
     # fit the data to the ordination as vectors
     ### vf() is timeconsuming, so this was generated
     ### in advance and saved.
     ### set.seed(1234)
     ### iris.vf <- vf(iris.nmin, iris[,1:4], nperm=1000)
     ### save(iris.vf, file="ecodist/data/iris.vf.rda")
     data(iris.vf)
     
     plot(iris.nmin, col=as.numeric(iris$Species), 
	    pch=as.numeric(iris$Species), main="NMDS")
     plot(iris.vf)
     data(iris)
     iris.d <- dist(iris[,1:4])
     
     ### nmds() is timeconsuming, so this was generated
     ### in advance and saved.
     ### set.seed(1234)
     ### iris.nmds <- nmds(iris.d, nits=20, mindim=1, maxdim=4)
     ### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
     data(iris.nmds)
     
     # examine fit by number of dimensions
     plot(iris.nmds)
     
     # choose the best two-dimensional solution to work with
     iris.nmin <- min(iris.nmds, dims=2)
     
     # rotate the configuration to maximize variance
     iris.rot <- princomp(iris.nmin)$scores
     
     # rotation preserves distance apart in ordination space
     cor(dist(iris.nmin), dist(iris.rot))
     
     # fit the data to the ordination as vectors
     ### vf() is timeconsuming, so this was generated
     ### in advance and saved.
     ### set.seed(1234)
     ### iris.vf <- vf(iris.nmin, iris[,1:4], nperm=1000)
     ### save(iris.vf, file="ecodist/data/iris.vf.rda")
     data(iris.vf)
     
     # repeat for the rotated ordination
     ### vf() is timeconsuming, so this was generated
     ### in advance and saved.
     ### set.seed(1234)
     ### iris.vfrot <- vf(iris.rot, iris[,1:4], nperm=1000)
     ### save(iris.vfrot, file="ecodist/data/iris.vfrot.rda")
     data(iris.vfrot)
     
     par(mfrow=c(1,2))
     plot(iris.nmin, col=as.numeric(iris$Species), 
	    pch=as.numeric(iris$Species), main="NMDS")
     plot(iris.vf)
     plot(iris.rot, col=as.numeric(iris$Species), 
	    pch=as.numeric(iris$Species), main="Rotated NMDS")
     plot(iris.vfrot)

```


# Example: Debugging a Broken Script

Code returns an error message, but the code is too messy and hard to
trace back to the error.

```{R debug, eval = FALSE}



```

# Example: Functions from Scripts

For example, here is a complicated, messy script:


```{R tangle, echo = TRUE, eval = FALSE}

### Data Munging
### More Data Munging
### Make a plot
### Run another analysis
### Make Another Plot

```

# Behind the Scenes: How Rclean Works

## Getting the Graph of Functions and Objects with Provenance

[\\]: # ### Provenance
[\\]: #     ## 1 Why?
[\\]: #     ## 2 What is it?
[\\]: #     ## 3 Prospective and retrospective
[\\]: #     ## 4 CodeDepends
[\\]: #     ## 5 Other projects: point to End-to-end/provClean

# Results Orientation

[\\]: # ### How variables are isolated
[\\]: #     ## 1 Single variable selection
[\\]: #     ## 2 How multiple variables are isolated
[\\]: # ### More complicated script example
[\\]: # ### Applied to Drake

# Final Thoughts

[\\]: # Drake
[\\]: # Other Workflow Projects
